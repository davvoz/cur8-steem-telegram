<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>CUR8 posting</title>
    <!--importa lo stile-->
    <link rel="stylesheet" href="style.css">
</head>
<style>
    /*spinner*/
    .spinner {
        position: absolute;
        margin: 0 auto;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    /* Aggiungi questo nuovo stile */
    .textarea-container {
        position: relative;
    }

    .spinner-border {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .hide {
        display: none;
    }

    /* Aggiungi questo nuovo stile per la lista delle comunità */
    .autocomplete-items div {
        padding: 10px;
        cursor: pointer;
        background-color: #fff;
        border-bottom: 1px solid #d4d4d4;
        color: black;
    }

    /* Aggiungi questo nuovo stile per l'elemento attivo */
    .autocomplete-active {
        background-color: DodgerBlue !important;
        color: 'red';
    }

    .autocomplete-items {
        position: absolute;
        border: 1px solid #d4d4d4;
        z-index: 99;
        left: 0;
        right: 0;
        max-height: 200px;
        /* Imposta un'altezza massima per evitare che la lista si espanda troppo */
        overflow-y: auto;
        /* Aggiungi uno scroll verticale se la lista è troppo lunga */
    }
</style>

<body>

    <h1>Cur8 posting</h1>

    <nav>
        <button onclick="showPage('draftPage')" id="draftBtn" disabled>
            <i class="material-icons">description</i>
            <span>Bozze</span>
        </button>
        <button onclick="showPage('postPage')" id="postBtn" disabled>
            <i class="material-icons">edit</i>
            <span>Pubblica</span>
        </button>
        <button onclick="showPage('accountPage')" id="accountBtn" disabled>
            <i class="material-icons">account_circle</i>
            <span>Account</span>
        </button>

    </nav>

    <!-- Pagina Login -->
    <div id="loginPage" class="page active">
        <h2>Login/Logout</h2>

        <label for="username">Username:</label>
        <input type="text" id="username" placeholder="Inserisci Username">

        <label for="postingKey">Posting Key:</label>
        <input type="text" id="postingKey" placeholder="Inserisci Posting Key">

        <button class="action-btn" onclick="login()">Login</button>
    </div>

    <!-- Pagina Gestione Bozze -->
    <div id="draftPage" class="page">
        <h2 id="titleGestionBozze">Gestione Bozze</h2>
        <!--lista delle bozze dell'username selezionato-->
        <ul id="draftList"></ul>
    </div>

    <!-- Pagina Pubblica Post -->
    <div id="postPage" class="page">
        <h2>Pubblica Post</h2>

        <div class="automplete-container">
            <label for="myInput">Comunità:</label>
            <input type="text" id="myInput" placeholder="Inizia a digitare...">
            <div id="autocomplete-list" class="autocomplete-items"></div>
        </div>

        <label for="postTitle">Titolo Post:</label>
        <input type="text" id="postTitle" placeholder="Inserisci Titolo Post">

        <label for="postBody">Corpo Post:</label>
        <div id="dropZone">
            Inserisci Immagine
            <input type="file" id="fileInput" style="display: none;" accept="image/*">
        </div>
        <div class="textarea-container">
            <textarea id="postBody" rows="5" placeholder="Inserisci Corpo del Post"></textarea>
            <div class="spinner hide" id="spinner">
                <div class="spinner-container">
                    <div class="spinner-border"></div>
                </div>
            </div>
        </div>

        <label for="postTags">Tag Post:</label>
        <input type="text" id="postTags" placeholder="Inserisci Tag separati da virgola">

        <button class="action-btn" onclick="postToSteem()">Pubblica Post</button>
        <!--salva bozza-->
        <button class="action-btn" onclick="salvaBozza()">Salva Bozza</button>
    </div>

    <!-- Pagina Gestione Account CRUD -->
    <div id="accountPage" class="page">
        <h2>Gestione Account Steem</h2>
        <ul id="accountList"></ul>
        <div class="actions-container">
            <button class="action-btn loginIn" onclick="showPage('loginPage')">
                <i class="material-icons">add</i>
                <span>Crea Account</span>
            </button>
        </div>
    </div>

    <div class="hide toast" id="toast">
        <h2>Risultato</h2>
        <pre id="result"></pre>
    </div>


    <script>
        // ApiClient class
        class ApiClient {
            constructor(baseUrl = 'https://imridd.eu.pythonanywhere.com') {
                this.apiKey = 'your_secret_api_key';
                this.baseUrl = baseUrl;
            }

            async sendRequest(endpoint, method, data = null) {
                const url = `${this.baseUrl}${endpoint}`;
                const options = {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        'API-Key': this.apiKey
                    },
                    body: data ? JSON.stringify(data) : null
                };

                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Error:', error);
                    throw error;
                }
            }

            login(idTelegram, username, postingKey) {
                return this.sendRequest('/login', 'POST', { id_telegram: idTelegram, username, posting_key: postingKey });
            }

            logout(idTelegram, username) {
                return this.sendRequest('/logout', 'POST', { id_telegram: idTelegram, username });
            }

            saveDraft(username, title, tags, body, scheduledTime, timezone) {
                return this.sendRequest('/save_draft', 'POST', { username, title, tags, body, scheduled_time: scheduledTime, timezone });
            }

            getUserDrafts(username) {
                return this.sendRequest(`/get_user_drafts?username=${username}`, 'GET');
            }

            deleteDraft(id, username) {
                return this.sendRequest('/delete_draft', 'DELETE', { id, username });
            }

            postToSteem(username, title, body, tags) {
                return this.sendRequest('/post_to_steem', 'POST', { username, title, body, tags });
            }

            createAccount(username, postingKey) {
                return this.sendRequest('/create_account', 'POST', { username, posting_key: postingKey });
            }

            readAccount(username) {
                return this.sendRequest(`/read_account?username=${username}`, 'GET');
            }

            updateAccount(username, postingKey) {
                return this.sendRequest('/update_account', 'PUT', { username, posting_key: postingKey });
            }

            deleteAccount(username) {
                return this.sendRequest('/delete_account', 'DELETE', { username });
            }

            checkLogin(idTelegram) {
                return this.sendRequest('/check_login', 'POST', { id_telegram: idTelegram });
            }

            listaComunities() {
                return this.sendRequest('/api/steem/communities', 'GET');
            }
        }

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const postBody = document.getElementById('postBody');
        let listaComunities;

        const input = document.getElementById("myInput");
        const autocompleteList = document.getElementById("autocomplete-list");
        let currentFocus = -1;

        input.addEventListener("input", function (e) {
            const val = this.value;
            closeAllLists();
            if (!val) {
                return false;
            }
            currentFocus = -1;
            const div = document.createElement("div");
            div.setAttribute("id", this.id + "autocomplete-list");
            div.setAttribute("class", "autocomplete-items");

            //dobbiamo mettere la lista delle comunità
            //all'interno di automplete-container
            this.parentNode.appendChild(div);

            listaComunities.then((communities) => {
                communities.forEach((community) => {
                    if (community.title.toLowerCase().indexOf(val.toLowerCase()) > -1) {
                        const item = document.createElement("div");
                        const matchStart = community.title.toLowerCase().indexOf(val.toLowerCase());
                        const matchEnd = matchStart + val.length;

                        item.innerHTML = community.title.substr(0, matchStart);
                        item.innerHTML += "<strong>" + community.title.substr(matchStart, val.length) + "</strong>";
                        item.innerHTML += community.title.substr(matchEnd);
                        item.innerHTML += `<input type='hidden' value='${community.title}'>`;

                        item.addEventListener("click", function (e) {
                            input.value = this.getElementsByTagName("input")[0].value;
                            // Aggiorna il campo dei tag con il nome della comunità
                            document.getElementById('postTags').value = community.name;
                            comunityName = community.name;
                            comunityTitle = community.title;
                            closeAllLists();
                        });

                        div.appendChild(item);
                    }
                });
            });
        });

        input.addEventListener("keydown", function (e) {
            let x = document.getElementById(this.id + "autocomplete-list");
            if (x) x = x.getElementsByTagName("div");
            if (e.keyCode == 40) {
                currentFocus++;
                addActive(x);
            } else if (e.keyCode == 38) {
                currentFocus--;
                addActive(x);
            } else if (e.keyCode == 13) {
                e.preventDefault();
                if (currentFocus > -1) {
                    if (x) x[currentFocus].click();
                }
            }
        });

        function addActive(x) {
            if (!x) return false;
            removeActive(x);
            if (currentFocus >= x.length) currentFocus = 0;
            if (currentFocus < 0) currentFocus = (x.length - 1);
            x[currentFocus].classList.add("autocomplete-active");
        }

        function removeActive(x) {
            for (let i = 0; i < x.length; i++) {
                x[i].classList.remove("autocomplete-active");
            }
        }

        function closeAllLists(elmnt) {
            const x = document.getElementsByClassName("autocomplete-items");
            for (let i = 0; i < x.length; i++) {
                if (elmnt != x[i] && elmnt != input) {
                    x[i].parentNode.removeChild(x[i]);
                }
            }
        }

        document.addEventListener("click", function (e) {
            closeAllLists(e.target);
        });

        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);

        async function getListaComunities() {
            try {
                const result = await client.listaComunities();
                displayResult(result, 'success');
                console.log(result);
                return result;
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                uploadImage(file);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                uploadImage(file);
            }
        }

        function uploadImage(file) {
            const reader = new FileReader();
            reader.readAsDataURL(file);

            reader.onloadend = function () {
                //spinner
                document.getElementById('spinner').classList.remove('hide');
                const base64Image = reader.result.split(',')[1]; // Estrarre solo la parte base64

                const payload = {
                    image_base64: base64Image,
                    username: usernameSelected
                };

                fetch('https://imridd.eu.pythonanywhere.com/api/steem/upload_base64_image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                })
                    .then(response => response.json())
                    .then(data => {
                        const imageUrl = data.image_url;
                        insertImageUrlInTextarea(imageUrl);
                        document.getElementById('spinner').classList.add('hide');
                    })
                    .catch(error => {
                        console.error('Errore durante il caricamento dell\'immagine:', error);
                        alert('Si è verificato un errore durante il caricamento dell\'immagine.');
                    });
            };

            reader.onerror = function (error) {
                console.error('Errore durante la lettura del file:', error);
                alert('Si è verificato un errore durante la lettura del file.');
            };
        }


        function insertImageUrlInTextarea(url) {
            const imageMarkdown = `![Immagine](${url})`;
            postBody.value += postBody.value ? `\n${imageMarkdown}` : imageMarkdown;
        }

        // UI handling
        let client;
        let usernames = [];
        let idTelegram;
        let usernameSelected = '';

        document.addEventListener('DOMContentLoaded', () => {
            idTelegram = initializeTelegram();
            initializeApp(idTelegram);
        });

        function salvaBozza() {
            const title = document.getElementById('postTitle').value;
            const tags = document.getElementById('postTags').value;
            const body = document.getElementById('postBody').value;
            saveDraft(title, tags, body, null, null);
            //refresh lista bozze
            getUserDrafts();
        }

        function initializeTelegram() {
            if (window.Telegram?.WebApp?.initDataUnsafe?.user?.id) {
                return window.Telegram.WebApp.initDataUnsafe.user.id;
            }
            console.warn('Telegram WebApp not available, using default ID');
            alert('Telegram WebApp not available, using default ID');
            return '6999103418';
        }

        async function initializeApp(userId) {
            client = new ApiClient();
            try {
                const result = await client.checkLogin(userId);
                enableNavigationButtons();
                initializeEnd(result);
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        function initializeEnd(result) {
            listaComunities = getListaComunities();
            usernames = result.usernames;
            const accountList = document.getElementById('accountList');
            accountList.innerHTML = '';
            usernames.forEach(createAccountListItem);
            if (usernames.length > 0) {
                usernameSelected = usernames[0];
                document.getElementById('titleGestionBozze').innerText = `Gestione Bozze di ${usernameSelected}`;
                getUserDrafts();
            }
            showPage('accountPage');
            displayResult(result);
        }

        function createAccountListItem(username) {
            const li = document.createElement('li');
            const container = document.createElement('div');
            container.classList.add('container-username');
            const span = document.createElement('span');
            span.innerText = username;
            span.classList.add('usernameElement');
            container.onclick = () => {
                selectAccount(username, container);
                usernameSelected = username;
                document.getElementById('titleGestionBozze').innerText = `Gestione Bozze di ${usernameSelected}`;
            };
            const buttonsContainer = document.createElement('div');
            const logoutButton = document.createElement('button');
            logoutButton.classList.add('action-btn');
            logoutButton.innerText = 'Logout';
            logoutButton.onclick = (event) => {
                usernameSelected = '';
                handleLogout(username);
            };
            buttonsContainer.classList.add('buttons-container');
            buttonsContainer.appendChild(logoutButton);
            container.appendChild(span);
            container.appendChild(buttonsContainer);
            li.appendChild(container);
            document.getElementById('accountList').appendChild(li);

        }

        function selectAccount(username, containerElement) {
            usernameSelected = username;

            document.querySelectorAll('.container-username').forEach(el => {
                el.classList.remove('selected');
            });

            containerElement.classList.add('selected');

            displayResult({ message: `Account ${username} selected` }, 'success');
            updateUIWithSelectedAccount();
            getUserDrafts();
        }

        function updateUIWithSelectedAccount() {
            const selectedAccountDisplay = document.getElementById('selectedAccountDisplay');
            if (selectedAccountDisplay) {
                selectedAccountDisplay.textContent = usernameSelected ? `Selected Account: ${usernameSelected}` : 'No account selected';
            }

            const accountDependentButtons = document.querySelectorAll('.account-dependent');
            accountDependentButtons.forEach(button => {
                button.disabled = !usernameSelected;
            });
        }

        async function handleLogout(username) {
            try {
                const result = await client.logout(idTelegram, username);
                displayResult(result, 'success');
                initializeApp(idTelegram);
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        function enableNavigationButtons() {
            ['draftBtn', 'postBtn', 'accountBtn'].forEach(id => {
                document.getElementById(id).disabled = false;
            });
        }

        function getUsername() {
            return usernameSelected;
        }

        function displayResult(result, type = 'success', enabled = false) {

            const toast = document.getElementById('toast');
            const pre = toast.querySelector('pre');
            pre.innerText = JSON.stringify(result, null, 2);
            toast.className = `show ${type}`;
            setTimeout(() => toast.classList.replace('show', 'hide'), 3000);
        }

        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
        }

        // API interaction functions
        async function login() {
            try {
                const result = await client.login(
                    idTelegram,
                    document.getElementById('username').value,
                    document.getElementById('postingKey').value
                );
                displayResult(result, 'success');
                initializeApp(idTelegram);
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        async function saveDraft() {

            try {
                const result = await client.saveDraft(
                    getUsername(),
                    document.getElementById('postTitle').value,
                    document.getElementById('postTags').value,
                    document.getElementById('postBody').value,
                    null, null
                );
                getUserDrafts(); // Refresh the draft list after saving the draft
                displayResult(result, 'success');
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        async function getUserDrafts() {
            try {
                const result = await client.getUserDrafts(getUsername());
                displayResult(result, 'success');
                createListaDrafts(result); // Call the function to create the draft list
                return result;
            } catch (error) {
                displayResult({ error: error.message }, 'error');
                return []; // Return an empty array in case of error
            }
        }
        // Create list of drafts
        function createListaDrafts(drafts) {
            const draftList = document.getElementById('draftList');
            draftList.innerHTML = ''; // Clear existing list
            if (Array.isArray(drafts) && drafts.length > 0) {
                drafts.forEach(draft => {
                    const li = document.createElement('li');
                    li.innerText = draft.title || 'Untitled Draft';
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.classList.add('buttons-container');
                    li.onclick = () => loadDraft(draft); // Add click event to load draft
                    li.classList.add('draft-item');
                    // Add a delete button to each draft
                    const deleteButton = document.createElement('button');
                    const deleteIcon = document.createElement('i');
                    deleteIcon.classList.add('material-icons');
                    deleteIcon.innerText = 'delete';
                    deleteButton.appendChild(deleteIcon);
                    deleteButton.onclick = (event) => {
                        deleteDraft(draft.id);
                    };

                    //editButton
                    const editButton = document.createElement('button');
                    const icon = document.createElement('i');
                    icon.classList.add('material-icons');
                    icon.innerText = 'edit';
                    editButton.appendChild(icon);

                    editButton.onclick = (event) => {
                        //apri la pagina del post e compila i campi con i dati della bozza
                        document.getElementById('postTitle').value = draft.title || '';
                        document.getElementById('postTags').value = draft.tags || '';
                        document.getElementById('postBody').value = draft.body || '';
                        showPage('postPage');

                    };
                    deleteButton.classList.add('action-btn-mini');
                    editButton.classList.add('action-btn-mini');
                    buttonsContainer.appendChild(editButton);
                    buttonsContainer.appendChild(deleteButton);
                    li.appendChild(buttonsContainer);
                    draftList.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.innerText = 'No drafts available';
                draftList.appendChild(li);
            }
        }
        // Load draft into the editor
        function loadDraft(draft) {
            document.getElementById('postTitle').value = draft.title || '';
            document.getElementById('postTags').value = draft.tags || '';
            document.getElementById('postBody').value = draft.body || '';
        }

        async function deleteDraft(id) {
            const draftId = id;
            if (!draftId) return;
            try {
                const result = await client.deleteDraft(draftId, getUsername());
                // Refresh the draft list after deleting the draft
                getUserDrafts();
                displayResult(result, 'success');
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        async function postToSteem() {
            try {
                const result = await client.postToSteem(
                    getUsername(),
                    document.getElementById('postTitle').value,
                    document.getElementById('postBody').value,
                    document.getElementById('postTags').value
                );
                displayResult(result, 'success');
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        async function createAccount() {
            try {
                const result = await client.createAccount(
                    document.getElementById('newUsername').value,
                    document.getElementById('newPostingKey').value
                );
                displayResult(result, 'success');
                initializeApp(idTelegram);
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        async function readAccount() {
            try {
                const result = await client.readAccount(document.getElementById('newUsername').value);
                displayResult(result, 'success');
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        async function updateAccount() {
            try {
                const result = await client.updateAccount(
                    document.getElementById('newUsername').value,
                    document.getElementById('newPostingKey').value
                );
                displayResult(result, 'success');
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

        async function deleteAccount() {
            try {
                const result = await client.deleteAccount(document.getElementById('newUsername').value);
                displayResult(result, 'success');
            } catch (error) {
                displayResult({ error: error.message }, 'error');
            }
        }

    </script>
</body>

</html>